// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by vst/generate_vst_params.py
#include "GeneratedAdditionalSettings.h"

namespace GeneratedAdditionalSettings {

// ChordQuality JSON conversion
NLOHMANN_JSON_SERIALIZE_ENUM(ChordQuality, {
    {ChordQuality::MAJOR, "MAJOR"},
    {ChordQuality::MINOR, "MINOR"},
    {ChordQuality::DOM_7, "DOM_7"},
    {ChordQuality::MAJOR_7, "MAJOR_7"},
    {ChordQuality::MINOR_7, "MINOR_7"},
    {ChordQuality::DIM_7, "DIM_7"},
    {ChordQuality::AUGMENTED, "AUGMENTED"},
    {ChordQuality::SUS_4, "SUS_4"},
    {ChordQuality::ADD_9, "ADD_9"},
})

void to_json(nlohmann::json& j, [[maybe_unused]] const RootPositionStyle& s) {
    j["type"] = RootPositionStyle::TYPE;
}

void from_json([[maybe_unused]] const nlohmann::json& j, [[maybe_unused]] RootPositionStyle& s) {
}

void to_json(nlohmann::json& j, const FileStyle& s) {
    j["type"] = FileStyle::TYPE;
    j["path"] = s.path;
}

void from_json(const nlohmann::json& j, FileStyle& s) {
    j.at("path").get_to(s.path);
}

void to_json(nlohmann::json& j, [[maybe_unused]] const Omni84Style& s) {
    j["type"] = Omni84Style::TYPE;
}

void from_json([[maybe_unused]] const nlohmann::json& j, [[maybe_unused]] Omni84Style& s) {
}

void to_json(nlohmann::json& j, [[maybe_unused]] const PlainAscendingStrumStyle& s) {
    j["type"] = PlainAscendingStrumStyle::TYPE;
}

void from_json([[maybe_unused]] const nlohmann::json& j, [[maybe_unused]] PlainAscendingStrumStyle& s) {
}

void to_json(nlohmann::json& j, [[maybe_unused]] const OmnichordStrumStyle& s) {
    j["type"] = OmnichordStrumStyle::TYPE;
}

void from_json([[maybe_unused]] const nlohmann::json& j, [[maybe_unused]] OmnichordStrumStyle& s) {
}

void to_json(nlohmann::json& j, const ButtonPerChordQuality& s) {
    j["type"] = ButtonPerChordQuality::TYPE;
    j["notes"] = s.notes;
    j["ccs"] = s.ccs;
}

void from_json(const nlohmann::json& j, ButtonPerChordQuality& s) {
    for (auto& [key, val] : j.at("notes").items()) {
        s.notes[std::stoi(key)] = val.get<ChordQuality>();
    }
    for (auto& [key, val] : j.at("ccs").items()) {
        s.ccs[std::stoi(key)] = val.get<ChordQuality>();
    }
}

void to_json(nlohmann::json& j, const CCRangePerChordQuality& s) {
    j["type"] = CCRangePerChordQuality::TYPE;
    j["cc"] = s.cc;
}

void from_json(const nlohmann::json& j, CCRangePerChordQuality& s) {
    j.at("cc").get_to(s.cc);
}

void to_json(nlohmann::json& j, const MidiNoteButton& s) {
    j["type"] = MidiNoteButton::TYPE;
    j["note"] = s.note;
}

void from_json(const nlohmann::json& j, MidiNoteButton& s) {
    j.at("note").get_to(s.note);
}

void to_json(nlohmann::json& j, const MidiCCButton& s) {
    j["type"] = MidiCCButton::TYPE;
    j["cc"] = s.cc;
    j["is_toggle"] = s.is_toggle;
}

void from_json(const nlohmann::json& j, MidiCCButton& s) {
    j.at("cc").get_to(s.cc);
    j.at("is_toggle").get_to(s.is_toggle);
}

void to_json(nlohmann::json& j, const ChordVoicingStyle& v) {
    std::visit([&j](const auto& val) {
        j = val;
    }, v);
}

void from_json(const nlohmann::json& j, ChordVoicingStyle& v) {
    std::string type = j.at("type").get<std::string>();
    if (type == RootPositionStyle::TYPE) {
        v = j.get<RootPositionStyle>();
    } else if (type == FileStyle::TYPE) {
        v = j.get<FileStyle>();
    } else if (type == Omni84Style::TYPE) {
        v = j.get<Omni84Style>();
    } else {
        throw std::runtime_error("Unknown type: " + type);
    }
}

void to_json(nlohmann::json& j, const StrumVoicingStyle& v) {
    std::visit([&j](const auto& val) {
        j = val;
    }, v);
}

void from_json(const nlohmann::json& j, StrumVoicingStyle& v) {
    std::string type = j.at("type").get<std::string>();
    if (type == PlainAscendingStrumStyle::TYPE) {
        v = j.get<PlainAscendingStrumStyle>();
    } else if (type == OmnichordStrumStyle::TYPE) {
        v = j.get<OmnichordStrumStyle>();
    } else {
        throw std::runtime_error("Unknown type: " + type);
    }
}

void to_json(nlohmann::json& j, const ChordQualitySelectionStyle& v) {
    std::visit([&j](const auto& val) {
        j = val;
    }, v);
}

void from_json(const nlohmann::json& j, ChordQualitySelectionStyle& v) {
    std::string type = j.at("type").get<std::string>();
    if (type == ButtonPerChordQuality::TYPE) {
        v = j.get<ButtonPerChordQuality>();
    } else if (type == CCRangePerChordQuality::TYPE) {
        v = j.get<CCRangePerChordQuality>();
    } else {
        throw std::runtime_error("Unknown type: " + type);
    }
}

void to_json(nlohmann::json& j, const LatchToggleButton& v) {
    std::visit([&j](const auto& val) {
        j = val;
    }, v);
}

void from_json(const nlohmann::json& j, LatchToggleButton& v) {
    std::string type = j.at("type").get<std::string>();
    if (type == MidiNoteButton::TYPE) {
        v = j.get<MidiNoteButton>();
    } else if (type == MidiCCButton::TYPE) {
        v = j.get<MidiCCButton>();
    } else {
        throw std::runtime_error("Unknown type: " + type);
    }
}

void to_json(nlohmann::json& j, const Settings& s) {
    j["chord_voicing_style"] = s.chord_voicing_style;
    j["strum_voicing_style"] = s.strum_voicing_style;
    j["chord_quality_selection_style"] = s.chord_quality_selection_style;
    j["latch_toggle_button"] = s.latch_toggle_button;
    j["stop_button"] = s.stop_button;
}

void from_json(const nlohmann::json& j, Settings& s) {
    j.at("chord_voicing_style").get_to(s.chord_voicing_style);
    j.at("strum_voicing_style").get_to(s.strum_voicing_style);
    j.at("chord_quality_selection_style").get_to(s.chord_quality_selection_style);
    j.at("latch_toggle_button").get_to(s.latch_toggle_button);
    j.at("stop_button").get_to(s.stop_button);
}

std::string toJson(const Settings& settings) {
    nlohmann::json j = settings;
    return j.dump();
}

Settings fromJson(const std::string& json) {
    auto j = nlohmann::json::parse(json);
    return j.get<Settings>();
}

bool isValidJson(const std::string& json) {
    try {
        fromJson(json);
        return true;
    } catch (...) {
        return false;
    }
}

Settings Settings::defaults() {
    return Settings{
        .chord_voicing_style = RootPositionStyle{},
        .strum_voicing_style = PlainAscendingStrumStyle{},
        .chord_quality_selection_style = ButtonPerChordQuality{.notes = {{0, ChordQuality::MAJOR}, {1, ChordQuality::MINOR}, {2, ChordQuality::DOM_7}}, .ccs = {}},
        .latch_toggle_button = MidiCCButton{.cc = 102, .is_toggle = true},
        .stop_button = MidiCCButton{.cc = 103, .is_toggle = false},
    };
}

}  // namespace GeneratedAdditionalSettings
